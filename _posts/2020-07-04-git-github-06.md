---
layout: post
title:  "[Git] 6. Git Conflict, Merge"
date:   2020-07-04
categories: Git Windows
---

이 포스팅은 `Git 세미나를` 위한 포스팅입니다.

---

이번 장에서는 Git을 사용함에 있어서 반드시 발생하는 충돌에 대해서 알아보려고 한다. 충돌이 생기는 원인과 해결법을 포함해도 브랜치 간 커밋을 합하는 병합을 포함한 내용이다

---

#### p4Merge 설치

밑에서 다룰 충돌 conflict가 발생했을 때 프로젝트 단위가 크다면 conflict를 해결을 하는데 난처해진다. 이는 tool을 사용하지 않을 떄의 얘기다. 그래서인지 third-party로 제공도니느 merge tool이 많이 존재한다. 그 중 가격과 성능(3-way-merge)이 우수하다고 판단되는 `p4merge`를 설치해보려고 한다. 이외에도 `KDiff3`도 우수하다는 평이 많으니, 참고해도 좋을 것 같다

1. 다음 [PERFORCE 링크](https://www.perforce.com/downloads/visual-merge-tool)로 들어가서 아래와 같이 설정한 후 확인을 누른다. 그 후 정보 입력 없이 `Skip Registration`을 누르면 바로 다운로드가 가능하다

   ![01](https://drive.google.com/uc?id=1ooieGLcPDj1wNp_5tJGuJjfpcTWDZbsU)

2. 설치파일을 실행한다. 모든 소프트웨어를 다운로드 받을 필요는 없고, `p4Merge`만 받도록 할 것이다. 그리고 설치 파일의 위치를 기억하도록 한다

   ![02](https://drive.google.com/uc?id=1yPZC6dtlR6Gkr4D_W03DskOJ73SlBqif)

3. 그러면 설치 디렉토리에 설치된 것을 확인할 수 있다

   ![03](https://drive.google.com/uc?id=1GbZxrbxTcGm3ATlEEE-mvZt4Tyf8AQJP)

---

#### p4Merge를 mergetool로 등록

Git 공식 [링크]([https://git-scm.com/book/ko/v2/Git%EB%A7%9E%EC%B6%A4-Git-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0](https://git-scm.com/book/ko/v2/Git맞춤-Git-설정하기))에서는 Linux에서 mergetool 설정을 하는 부분이 장황하게 설명되어 있지만, Window에서 Git-bash를 이용하면 쉽게 p4Merge를 mergetool로 설정할 수 있게 된다

1. __바탕화면(어디든지 상관없다)에서 Git-bash를 열도록 한다.__

   ![04](https://drive.google.com/uc?id=1bNOG16gtSchbGXJDbN6Otz8moZfW2ZVz)

2. 그리고 다음 명령들을 순서대로 입력하도록 한다. p4Merge 디렉토리는 PC마다 다를 수 있기에 반드시 체크 후에 기입하도록 한다

   ```bash
   $ git config --global merge.tool p4merge
   $ git config --global mergetool.p4merge.cmd 'p4merge $BASE $LOCAL $REMOTE $MERGED'
   $ git config --global mergetool.p4merge.path 'C:\Program Files\Perforce\p4merge.exe'
   ```

   ![05](https://drive.google.com/uc?id=1rqJ3fHKKKSOWkbRKMxWW12hq10kiejGA)

3. 그러면 `C:\Users\사용자\.gitconfig`에 위에서 적용한 내용을 확인할 수 있다

   ![06](https://drive.google.com/uc?id=103Q1p09NDYsi8jkPJfStRXFFzA5A8yzR)

---

#### 병합의 원리 3-way-merge

병합은 쉽게 말해 두 버전을 합하는 행동을 말한다. 두 버전이라고 하면 서로 다른 브랜치에서 개발된 서로 다른 버전의 커밋을 말하는 것이다. __브랜치를 만들었던 이유는 새로운 기능을 추가하기 위해서였다. 따라서 기능 개발이 완료된 이후 합치기 위해서 반드시 병합 과정을 거쳐야만 한다.__

이제 아래에서 다룰 `충돌`을 다뤄보려고 한다. 그런데 병합을 하는 과정에서 충돌이 반드시 발생하는 것은 아니다. 충돌은 발생할수도 있고, 운이 좋다면 혹은 설계를 잘했다면 발생을 하지 않는 것이다. 그런데 이를 추측하는 것이 아닌 병합의 원리인 `3-way-merge`를 이해하면 충돌이 날지 안날지를 알수가 있다. __이는 Git 말고도 다른 버전관리 시스템에서 사용되는 merge 방법이다. 예전에는 2-way-merge 기법을 사용했는데 매우 비효율적이라 최근에는 3-way-merge로 나오는 것이다__

![07](https://drive.google.com/uc?id=1JvPYRlbF77EVPf7QB1_h9nj5Y6uGr7H1)

위에서 기입되어 있는데 한 파일에서 Line마다 작성된 문자들을 말한다. master와 feature간의 마지막 공통 커밋이 있을 것이다. 예를 들면 다음과 같다. __초록색으로 박스쳐진 것이 두 브랜치의 공통 커밋이고 이를 merge에서는 base라고 지칭한다.__

![08](https://drive.google.com/uc?id=13HHQwQ9yk_COk8Xe_PwUosNSZif0mGSd)

base가 중요한 것은 base 기준으로 두 브랜치의 변경사항을 비교하게 된다. 총 아래 3가지의 경우로 나눠지게 된다

1. base == master == feature라면 변경사항 없이 그대로
2. base == master != feature라면 feature가 변경한 것이므로 수정사항 우선으로 feature가 된다
3. base != master &&  base != feature라면 두 브랜치 모두 변경한 사항이므로 충돌을 발생시키고 사용자에게 원하는 선택을 하게 한다

base가 있다보니 `2-way-merge`보다 충돌 횟수가 적어지는 것을 볼 수 있다. 실제 실습을 통해 해보려고 한다. __한가지 유의할 점이 있다. 위에서는 Line마다 비교했는데, 실제로는 먼저 같은 부분을 지정한 다음 그 사이를 탐색하게 된다. 그리고 실제로 프로젝트에서는 저렇게 파일을 작성할 이유는 없기 때문에 앞서 언급한 방법으로 diff를 한 후 충돌 구간을 정의하는 것이 맞는 말이다.__ 실제로 실습을 통해서 알아보려고 한다

* 서로 다른 브랜치에서의 충돌이 나지 않는 경우
* 서로 다른 브랜치에서의 충돌
* 원격 저장소와 충돌 (fetch와 pull 비교)
* merge 커밋과 fast-forward 병합